// C, C++ 사용법 모음 //


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// visual studio 2019
// 프로젝트 이름(visual studio 안에서 분리되는 이름)
// 솔루션 이름('위치'에서 생성되는 폴더 이름)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// main에서 정의한 배열을 함수에 넣었을때
// 호출된 함수 내에서 sizeof 한 경우 제대로 사이즈가 나오지 않는다.
// 따라서 보통은 main에서 sizeof를 하고 그 int값을 넘긴다.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 헤더를 만드는 이유
/*
이미 선언한 함수를 활용해야 할 때
활용할 함수보다 위에서 선언하면 활용하기 힘들다.
선언의 위치에 따라서 코딩에 제약을 받는다.
이러한 불편함을 해소하기 위해서 헤더를 만들어서 사용한다.

코드의 가독성을 높여 디버깅이 편리하다.
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// .cpp에서 C언어로 작성된 헤더를 #include 하기위한 .c 와 .h의 수정 방법 //
// 기본적으로 헤더파일은 .h와 .c(또는.cpp)의 2개의 파일로 이뤄진다.
/*
C언어로 작성된 abcd.c 와 abcd.h가 있으면 abcd.h에만 다음과 같이 주석처리한다.

#ifdef __cplusplus
extern "C" {
#endif

코드

#ifdef __cplusplus
}
#endif

*/

// 이후 컴파일 할 솔루션의 폴더에 .c와 .h를 넣고 visual studio의 '헤더 파일' 에도 추가해준다.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 컴파일시 헤더 중복방지
/*
#ifndef __ARRAY_LIST_H__ 
#define __ARRAY_LIST_H__
코드
#endif
*/
// 이렇게 입력하면 컴파일시 ArrayList.h헤더의 중복 호출이 방지된다.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// visual studio 2019에서 scanf 경고 무시방법
#pragma warning(disable: 4996)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////










////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 0. 함수의 함수 호출
// '함수 포인터'를 사용한다.
#include <stdio.h>

// int형 반환, int형 매개변수 두 개
int test_add(int a, int b)
{
	return a + b;
}
// 함수 포인터를 매개변수로 지정
void executer(int (*fp)(int, int))
{
	printf("%d\n", fp(10, 20));    // 30: 매개변수로 함수 호출
}
int main()
{
	executer(test_add);    // executer를 호출할 때 add 함수의 메모리 주소를 전달
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1. 구조체 만들기 (C)
#include <stdio.h>

typedef struct Person_structure
{                           // 이름은 Person_structure
	char name[20];          // 구조체 멤버 1
	int age;                // 구조체 멤버 2
	char address[100];      // 구조체 멤버 3
} Person;                   // 실제 이름은 길 수 있으므로 별칭을 Person으로 정의

int main()
{
	// 위에서 작성한 구조체의 별칭 Person으로 p1 선언
	Person p1;

	// 구조체 멤버에 .으로 접근하여 값 할당
	// strcpy 함수 사용법 : p1.name에 홍길동 을 넣는다.
	// C언어에서 char name[20]에 바로 "홍길동"을 넣는 방법은 없다.
	// 따라서 strcpy 함수를 사용한다.
	strcpy(p1.name, "홍길동");
	p1.age = 30;
	strcpy(p1.address, "서울시 용산구 한남동");

	printf("이름: %s\n", p1.name);       // 이름: 홍길동
	printf("나이: %d\n", p1.age);        // 나이: 30
	printf("주소: %s\n", p1.address);    // 주소: 서울시 용산구 한남동

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 2. 메모리 할당, 해제(new, delete) (C++) 
#include <iostream>
// iostream : C++ 표준 입출력 코드가 포함된 헤더 (std::cout 이나 std::endl 과 같은 것들)
// C의 stdio.h 와 비슷한 맥락 (C와 다른 점은 .h 가 붙지 않음)
int main()
{
	int arr_size;

	std::cout << "array size : ";
	std::cin >> arr_size;

	// new는 c의 malloc과 같은 기능
	// int형 array를 arr_size 만큼 heap영역에 생성하고 list라는 이름으로 할당
	int* list = new int[arr_size];

	for (int i = 0; i < arr_size; i++)
	{
		std::cout << "input value : ";
		std::cin >> list[i];
	}
	for (int i = 0; i < arr_size; i++) {
		std::cout << "list index " << i << " = " << list[i] << std::endl;
	}

	// 메모리 해제
	delete[] list;

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 3. class (C++)
// 객체 지향 프로그래밍
// 1세대 언어 : 진공관 배열
// 2세대 언어 : 어셈블리어 (Assembly language)
				// 어셈블리어 (low level)
				// COBOL, FORTRAN, BASIC (high level)
				// 첫번째 1 을 어디에 저장해라 -> 두번째 1 을 어디에 저장해라
				// CPU의 메모리 어디에서 첫번째와 두번째 1 을 불러와라
				// 덧셈을 수행해라
// 3세대 언어 : 절차 지향 언어 (Procedural programming language)
				// Pascal, C
				// 함수 변수 등이 도입됨
// 4세대 언어 : 객체 지향 언어 (Object oriented language)
				// 프로그램의 크기가 커지면서 생기게 됨
				// 즉 class안에 필요한 함수를 담아서 활용한다. = 객체 지향 언어
#include <iostream>

class class_animal
{
private:
	// private로 선언한 변수, 함수는 현재 정의하고있는 class_animal의 {} 안에서 접근, 변경이 가능하다.
	// class_animal의 {}를 벗어나면 변경 불가. 즉 main 에서는 변경 할 수 없다.
	// public과 같은 키워드 명시를 하지 않았다면 기본적으로 private 로 설정된다.
	int food;
	int weight;

public:
	// public으로 선언한 변수, 함수는 main 에서도 접근, 변경 가능하다.

	void view_stat()
	{
		std::cout << "이 동물의 food   : " << food << std::endl;
		std::cout << "이 동물의 weight : " << weight << std::endl;
	}
	void set_animal(int _food, int _weight)
	{
		food = _food;
		weight = _weight;
	}
	void increase_food(int inc);
	// class 내부에서 void set_animal(int _food, int _weight) 함수처럼 함수 전체를 구현하지 않고
	// void increase_food(int inc); 처럼 밖에서 함수를 선언하고 클래스에 포함시켜 가독성을 높이는 방법을 주로 사용한다.
	// 클래스에 넣기위한 함수를 밖에서 생성할때는 함수 이름 앞에 클래스 명을 붙여야 클래스에 포함된다.
	// 예를들어 void class_animal::increase_food(int inc) 처럼 선언해야한다.
};	// 반드시 클래스 마지막은 세미콜론을 붙인다.

// 함수에 클래스명 ' class_animal:: ' 을 붙이고
// 클래스 내부에 void increase_food(int inc); 를 넣는다.
void class_animal::increase_food(int inc)
{
	food += inc;
	weight += (inc / 3);
}

/*
클래스와 관련없이 선언하는 함수는 보통 이렇다.
void increase_food(int inc)
{
	food += inc;
	weight += (inc / 3);
}
*/


int main()
{
	class_animal animal;
	// 위에서 작성한 class_animal로 animal 선언

	animal.set_animal(100, 50);
	animal.view_stat();

	std::cout << "\nincrease food 30\n" << std::endl;

	animal.increase_food(30);
	animal.view_stat();

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 4. 생성자 (C++)
// class 선언시 초기화를 목적으로 만든 함수

#include <iostream>

class Date
{
	// 별다른 언급 없이 선언하면 private로 선언된다.
	int year_;
	int month_;  // 1 부터 12 까지.
	int day_;    // 1 부터 31 까지.

public:
	void AddYear(int inc);
	void ShowDate();

	////////////////// 이 부분을 생성자라고 한다. //////////////////
	// public으로 선언되었으므로 호출가능하다.
	// 이런식으로 내부의 private 변수를 수정 가능하다.
	Date(int year, int month, int day)
	{
		year_ = year;
		month_ = month;
		day_ = day;
	}
	////////////////// 이 부분을 생성자라고 한다. //////////////////
};

void Date::AddYear(int inc)
{
	year_ += inc;
}
void Date::ShowDate()
{
	std::cout << "오늘은 " << year_ << " 년 " << month_ << " 월 " << day_
		<< " 일 입니다 " << std::endl;
}

int main()
{
	// 생성자와 함께 변수 생성방법
	// Date day(2011, 3, 1);			// 암시적 방법 (implicit)
	// Date day = Date(2012, 3, 1);		// 명시적 방법 (explicit)
	// 만약 Date day; 로 선언하고 함수를 실행하면 실행은 된다.
	// 다만 값이 초기화된것이 아니라 임의의 값이 나오게된다.

	Date day(2011, 3, 1);
	day.ShowDate();

	day.AddYear(10);
	day.ShowDate();

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 5. 가상함수
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
































































// 배경지식 //

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
함수는 1개의 기능만 하도록 만든다.
array 리스트에 int를 담는 함수를 작성했었다.
이 함수를 활용하여 새로 정의한 struct의 주소를 담은 array 리스트를 만들려고 했는데
이전에 작성한 조회, 삭제 함수는 int형으로 반환받고 값을 활용하여 처리하도록 만들었기 때문에 모든 함수를 다시 작성해야했다.
처음부터 함수를 1개의 기능만 하도록 만들었다면 세부내용만 덧붙이면 되니까 시간이 절약됐을것 이다.
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
에라토스테네스의 체 : 소수를 구하는 쉬운 방법
예를들어 2~120까지 소수를 구한다.
1은 소수가 아니다.
제곱수가 120을 넘는지 확인한다.
2빼고 2 배수 지운다.
3빼고 3 배수 지운다.
5빼고 5 배수 지운다.
7빼고 7 배수 지운다.
11제곱은 121이다.
13제곱은 169이다.
4,6,8,9,10은 배수중에 포함되니까 안한다.
남은수가 소수다.
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////
// 배열 순환시키기 //
#include <iostream>
#include <stdio.h>

void move_forward(int input_array[], int k, int length_array)
{
	int start_index = 0;
	int next_index = 0;

	int temp_value_1 = 0;
	int temp_value_2 = input_array[start_index];

	int count = 0;
	while (count < length_array)
	{
		next_index = (length_array + start_index - k) % length_array;
		temp_value_1 = input_array[next_index];
		input_array[next_index] = temp_value_2;
		temp_value_2 = temp_value_1;
		start_index = next_index;
		for (int i = 0; i < length_array; i++)
		{
			printf("%d", input_array[i]);
		}
		std::cout << std::endl;
		count++;
	}
}

int main()
{
	int input_array[5] = { 1,2,3,4,5 };
	int k = 2;
	int length_array = sizeof(input_array) / sizeof(input_array[0]);

	move_forward(input_array, k, length_array);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////










